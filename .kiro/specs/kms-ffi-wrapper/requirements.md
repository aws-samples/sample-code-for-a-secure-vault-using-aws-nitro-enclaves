# Requirements Document

## Introduction

This document specifies the requirements for replacing the current subprocess-based KMS integration (`kmstool_enclave_cli`) in the enclave application with a native Rust FFI wrapper that directly calls the AWS Nitro Enclaves SDK C library. This approach follows the proven pattern used by the [aws-nitro-enclaves-acm](https://github.com/aws/aws-nitro-enclaves-acm/tree/main/src/vtok_srv/src/aws_ne) project.

This change will eliminate process spawning overhead, improve error handling, reduce Docker image complexity, and provide better memory safety through Rust's ownership model.

## Glossary

- **Enclave Application**: The Rust application running inside the AWS Nitro Enclave that handles decryption requests
- **KMS**: AWS Key Management Service used to decrypt the HPKE private key
- **FFI**: Foreign Function Interface - mechanism for calling C functions from Rust
- **aws-nitro-enclaves-sdk-c**: The official AWS C SDK for Nitro Enclaves that provides KMS integration with attestation
- **kmstool_enclave_cli**: The current CLI tool used via subprocess to perform KMS decrypt operations
- **Attestation Document**: A cryptographically signed document generated by the Nitro Enclave that proves the enclave's identity and state
- **vsock**: Virtual socket used for communication between the enclave and parent instance (parent CID is always 3)
- **HPKE Private Key**: The private key used for Hybrid Public Key Encryption, stored encrypted with KMS
- **aws_byte_buf**: C struct from aws-c-common library representing a byte buffer with length, capacity, and allocator
- **aws_string**: C struct from aws-c-common library representing an immutable string

## Requirements

### Requirement 1

**User Story:** As a developer, I want to create Rust FFI bindings for the AWS Nitro Enclaves SDK C library, so that I can call KMS functions directly from Rust without spawning a subprocess.

#### Acceptance Criteria

1. WHEN the FFI module is created THEN the FFI Module SHALL declare extern "C" bindings for `aws_nitro_enclaves_library_init`, `aws_nitro_enclaves_library_clean_up`, and `aws_nitro_enclaves_get_allocator` functions
2. WHEN the FFI module is created THEN the FFI Module SHALL declare extern "C" bindings for `aws_kms_decrypt_blocking` function
3. WHEN the FFI module is created THEN the FFI Module SHALL declare extern "C" bindings for `aws_nitro_enclaves_kms_client_config_default`, `aws_nitro_enclaves_kms_client_new`, `aws_nitro_enclaves_kms_client_destroy`, and `aws_nitro_enclaves_kms_client_config_destroy` functions
4. WHEN the FFI module is created THEN the FFI Module SHALL declare extern "C" bindings for `aws_string_new_from_array`, `aws_string_destroy_secure`, `aws_byte_buf_from_array`, and `aws_byte_buf_clean_up_secure` functions
5. WHEN the FFI module is created THEN the FFI Module SHALL define Rust repr(C) structs for `aws_byte_buf`, `aws_socket_endpoint`, and opaque pointer types for `aws_string`, `aws_allocator`, `aws_nitro_enclaves_kms_client`, and `aws_nitro_enclaves_kms_client_configuration`

### Requirement 2

**User Story:** As a developer, I want a safe Rust wrapper around the FFI calls, so that I can use the KMS decrypt functionality without writing unsafe code in the main application.

#### Acceptance Criteria

1. WHEN the `kms_decrypt` function is called THEN the KMS Module SHALL initialize the SDK using `aws_nitro_enclaves_library_init`, perform decryption, and clean up all resources using `aws_nitro_enclaves_library_clean_up` in a single function call
2. WHEN the SDK is initialized THEN the KMS Module SHALL obtain the allocator using `aws_nitro_enclaves_get_allocator` for all subsequent memory allocations
3. WHEN credentials are provided THEN the KMS Module SHALL create `aws_string` instances for region, access_key_id, secret_access_key, and session_token using `aws_string_new_from_array`
4. WHEN a KMS client is needed THEN the KMS Module SHALL configure the vsock endpoint with address "3" (parent CID) and port 8000 (proxy port) using `aws_nitro_enclaves_kms_client_config_default`
5. WHEN the KMS client is configured THEN the KMS Module SHALL create the client using `aws_nitro_enclaves_kms_client_new`
6. WHEN decryption is requested THEN the KMS Module SHALL call `aws_kms_decrypt_blocking` which internally generates an attestation document, sends it to KMS, and decrypts the response
7. WHEN decryption completes successfully THEN the KMS Module SHALL copy the plaintext from the C buffer to a Rust `Vec<u8>` before cleaning up
8. WHEN any FFI call returns a null pointer or error code THEN the KMS Module SHALL clean up all previously allocated resources before returning an error

### Requirement 3

**User Story:** As a developer, I want to replace the subprocess call with direct FFI calls, so that I can eliminate process spawning overhead and improve performance.

#### Acceptance Criteria

1. WHEN the `call_kms_decrypt` function is invoked THEN the KMS Integration SHALL call the new `kms_decrypt` FFI wrapper instead of `Command::new("/app/kmstool_enclave_cli")`
2. WHEN the FFI wrapper returns plaintext bytes THEN the KMS Integration SHALL use the bytes directly without parsing "PLAINTEXT: " prefixes
3. WHEN the FFI wrapper returns an error THEN the KMS Integration SHALL convert the error to an `anyhow::Error` with a descriptive message

### Requirement 4

**User Story:** As a developer, I want proper error handling for FFI calls, so that I can diagnose issues and handle failures gracefully.

#### Acceptance Criteria

1. WHEN SDK initialization fails THEN the Error Handling SHALL return an `SdkInitError` variant
2. WHEN string allocation fails THEN the Error Handling SHALL return an `SdkGenericError` variant and clean up previously allocated resources
3. WHEN KMS client configuration fails THEN the Error Handling SHALL return an `SdkKmsConfigError` variant
4. WHEN KMS client creation fails THEN the Error Handling SHALL return an `SdkKmsClientError` variant
5. WHEN KMS decryption fails THEN the Error Handling SHALL return an `SdkKmsDecryptError` variant

### Requirement 5

**User Story:** As a developer, I want to simplify the Docker build process, so that I can reduce image size and build complexity.

#### Acceptance Criteria

1. WHEN building the enclave crate THEN the Build System SHALL include a `build.rs` that links against `aws-c-common` and `aws-nitro-enclaves-sdk-c` shared libraries
2. WHEN the final Docker image is created THEN the Build System SHALL exclude the `kmstool_enclave_cli` binary from the image
3. WHEN the final Docker image is created THEN the Build System SHALL include the `libaws-c-common.so` and `libaws-nitro-enclaves-sdk-c.so` shared libraries

### Requirement 6

**User Story:** As a developer, I want sensitive credential data to be properly handled, so that secrets are not leaked in memory.

#### Acceptance Criteria

1. WHEN credentials are no longer needed THEN the Security Module SHALL call `aws_string_destroy_secure` to securely erase credential strings from memory
2. WHEN the decrypted plaintext buffer is no longer needed THEN the Security Module SHALL call `aws_byte_buf_clean_up_secure` to securely erase the plaintext from memory
3. WHEN errors occur during decryption THEN the Security Module SHALL ensure all allocated resources are cleaned up before returning
